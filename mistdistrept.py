#takes input from parsed JSON files from MIST and makes a comprehensive summary
#report part1 = dictionary of key of strains, values of genes they are missing
#report part2 = dictionary of key of genes, values of strains that lack those genes

import argparse
import json
import glob
import os
import string
import multiprocessing
from functools import partial
import csv

def pathfinder(outpath):
    '''makes directory for report file'''
    if not os.access(outpath, os.F_OK):
        os.mkdir(outpath)

def fileget(path):
    '''collects all json files generated by MIST'''
    files = glob.glob(path+'*.json')
    return files

def reader(files):
    '''reads the json files'''
    with open(files) as f:
        data = json.load(f)
    return data


def strainget(data, testtypename, files):
    '''provides the strain name, number of genes the genome does not have, and a list of genes
    that did not match for the genome used as primary source of information for part1 of report'''
    genes = data['Results'][0]['TestResults'][testtypename] #saves this section of the json
                                                            #into genes for easier future access
    genesmissing = 0
    genelist = []
    for gene in genes: #access each gene in the dictionary
        if genes[gene]['CorrectMarkerMatch'] == False or genes[gene]['IsContigTruncation'] == True:
            genelist.append(gene)
            genesmissing+=1 #gets number of genes missing in the json file for the strain
            #returns strain name, number of genes missing, and the list of gene names missing
    return os.path.splitext(os.path.basename(files))[0][:-len(testtypename)], genesmissing, genelist

def testnamegetter(testtype):
    with open(testtype, 'r') as f:
        reader=csv.reader(f, delimiter='\t')
        next(reader, None)
        for x in reader:
            testname=x[1]
            return testname

def genes(genelist, dwriter):
    '''takes in a list of all genes that have misses and a dictionary of k=strain v=list of missing genes,
    returns a dictionary of k=genes v=strains that lack it for part 2 of the report'''
    dmisslist={}
    for gene in genelist:
        dmisslist[gene]=[] #makes empty list for every gene in the list of genes for future appending
    for strain in dwriter:
        for index, genes in enumerate(dwriter[strain]):
            dmisslist[genes].append(strain)
    return dmisslist

def genetotal(testtype):
    '''returns all genes in the .markers file'''
    with open(testtype, 'r') as f:
        data = f.readlines()
        genelist = []
        for x in range(1, len(data)): #skips the header
            genelist.append(data[x].split()[0])
        return genelist

def mult(item, testtypename):
    '''generates a list of dictionaries that contain strains that a gene is missing from in parallel(later)'''
    dwriter = {}
    if not os.stat(item).st_size == 0: #skips empty json files
        data = reader(item)
        missingno = strainget(data, testtypename, item)
        dwriter[missingno[0]] = missingno[2] #returns dictionary of key strain name, value list of genes missing
    else:
        print('Skipping file '+item+' due to empty .json file')
    return dwriter


def JSONwriter(outpath, outfile, dwriter, dmisslist):
    '''writes the report into a json file'''
    letterlist = ['']
    letterlist = letterlist + list(string.ascii_lowercase)  #in case a report file already exists, appends a
    for letter in letterlist:                                  #lowercase letter on to the end
        if os.path.isfile(os.path.join(outpath, outfile+letter+'.json')):
            pass
        else:
            with open(os.path.join(outpath, outfile+letter+'.json'), 'a') as f:
                data = {'GenomesMissingGenes': dwriter, 'GenesMissingGenomes': dmisslist}
                json.dump(data, f, indent=4, sort_keys=True)
            return

def arguments():
    parser = argparse.ArgumentParser()
    parser.add_argument('--outpath', default='./mistfail/')
    parser.add_argument('--outfile', default='report')
    parser.add_argument('-t', '--testtype', required = True)
    parser.add_argument('-T', '--testtypename', required=True)
    parser.add_argument('-c', '--cores', default=multiprocessing.cpu_count())
    parser.add_argument('path')
    return parser.parse_args()

def process(path, outpath, outfile, testtype, cores):
    pool = multiprocessing.Pool(int(cores))
    pathfinder(outpath)
    files = fileget(path)
    testtypename=testnamegetter(testtype)
    dwriter={}
    genelist = genetotal(testtype)
    fatdwriter = pool.map(partial(mult, testtypename=testtypename), files) #saves into a two levelled list in parallel
    for dictionary in fatdwriter:
        for key, value in dictionary.items():
            dwriter[key]=value
    dmisslist=genes(genelist, dwriter)
    JSONwriter(outpath, outfile, dwriter, dmisslist)

def main():
    args = arguments()
    process(args.path, args.outpath, args.outfile, args.testtype, args.cores)


if __name__ == '__main__':
    main()