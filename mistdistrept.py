# takes input of a directory of parsed JSON files from MIST and makes a comprehensive summary
# report part1 = dictionary of key of strains, values of genes they are missing
# report part2 = dictionary of key of genes, values of strains that lack those genes

import argparse
import json
import glob
import os
import string
import multiprocessing
from functools import partial
import csv
import re

def pathfinder(outpath):
    '''makes directory for report file'''
    if not os.access(outpath, os.F_OK):
        os.mkdir(outpath)

def fileget(path):
    '''collects all json files generated by MIST'''
    files = glob.glob(os.path.join(path, '*.json'))
    return files

def reader(files):
    '''reads the json files'''
    with open(files) as f:
        data = json.load(f)
    return data


def strainget(data, testtypename, files):
    '''provides the strain name, number of genes the genome does not have, and a list of genes
    that did not match for the genome used as primary source of information for part1 of report'''
    genes = data['Results'][0]['TestResults'][testtypename] #saves this section of the json
                                                            #into genes for easier future access
    genesmissing = 0
    genelist = []
    for gene in genes: #access each gene in the dictionary
        if genes[gene]['CorrectMarkerMatch'] == False or genes[gene]['IsContigTruncation'] == True:
            genelist.append(gene)
            genesmissing+=1 #gets number of genes missing in the json file for the strain
            #returns strain name, number of genes missing, and the list of gene names missing
    return os.path.splitext(os.path.basename(files))[0][:-len(testtypename)], genesmissing, genelist

def testnamegetter(testtype):
    '''retrieves the name of the test directly from markers file'''
    with open(testtype, 'r') as f:
        try: #try accessing markers file as .json file first
            data = json.load(f)
            for genome, keys in data.items():
                for key in keys:
                    if re.match('T(est)?\.?[-\._ ]?Name.*', key, flags=re.IGNORECASE):
                        return keys[key]

        except ValueError: #if access as .json file fails, try to access as csv file
            f.seek(0)
            reader=csv.reader(f, delimiter='\t')
            next(reader, None)
            for x in reader:
                testname=x[1]
                return testname

def genes(genelist, dwriter):
    '''takes in a list of all genes that have misses and a dictionary of k=strain v=list of missing genes,
    returns a dictionary of k=genes v=strains that lack it for part 2 of the report'''
    dmisslist={}
    for gene in genelist:
        dmisslist[gene]=[]  # makes empty list for every gene in the list of genes for future appending
    for strain in dwriter:
        for index, genes in enumerate(dwriter[strain]):  # loops through a list of genes missing and creates a key of
                                                        # them in a dictionary, with values of a list of the strains
                                                        # that are missing that gene
            dmisslist[genes].append(strain)
    return dmisslist

def genetotal(testtype):
    '''returns all genes in the .markers file'''
    with open(testtype, 'r') as f:
        genelist = []
        try:  # gets all gene names from the marker dictionary keys if marker file is json
            for gene in json.load(f):
                genelist.append(gene)
        except ValueError:  # if marker file isn't json, tries csv format instead
            f.seek(0)
            data = f.readlines()
            for x in range(1, len(data)): #skips the header
                genelist.append(data[x].split()[0])
        return genelist

def mult(item, testtypename):
    '''generates a list of dictionaries that contain strains that a gene is missing from in parallel(later)'''
    dwriter = {}
    if not os.stat(item).st_size == 0: #skips empty json files
        data = reader(item)
        missingno = strainget(data, testtypename, item)
        dwriter[missingno[0]] = missingno[2] #returns dictionary of key strain name, value list of genes missing
    else:
        print('Skipping file '+item+' due to empty .json file')
    return dwriter


def JSONwriter(outpath, outfile, dwriter, dmisslist):
    '''writes the report into a json file'''
    letterlist = ['']
    letterlist = letterlist + list(string.ascii_lowercase)  #in case a report file already exists, appends a
    for letter in letterlist:                                  #lowercase letter on to the end
        if os.path.isfile(os.path.join(outpath, outfile+letter+'.json')):
            pass
        else:
            with open(os.path.join(outpath, outfile+letter+'.json'), 'a') as f:
                data = {'GenomesMissingGenes': dwriter, 'GenesMissingGenomes': dmisslist}
                json.dump(data, f, indent=4, sort_keys=True)
            return

def arguments():
    parser = argparse.ArgumentParser()
    parser.add_argument('--outpath', default='./mistreport/', help='directory for report file output')
    parser.add_argument('--outfile', default='report', help='output file name')
    parser.add_argument('-t', '--testtype', required = True, help='markers file, json or csv formatted')
    parser.add_argument('-c', '--cores', default=multiprocessing.cpu_count(), help='how many CPUs to run on')
    parser.add_argument('path')
    return parser.parse_args()

def process(path, outpath, outfile, testtype, cores):
    pool = multiprocessing.Pool(int(cores))
    pathfinder(outpath)
    files = fileget(path)
    testtypename=testnamegetter(testtype)
    dwriter={}
    genelist = genetotal(testtype)
    fatdwriter = pool.map(partial(mult, testtypename=testtypename), files) #saves into a two levelled list in parallel
    for dictionary in fatdwriter:
        for key, value in dictionary.items():
            dwriter[key]=value
    dmisslist=genes(genelist, dwriter)
    JSONwriter(outpath, outfile, dwriter, dmisslist)

def main():
    args = arguments()
    process(args.path, args.outpath, args.outfile, args.testtype, args.cores)


if __name__ == '__main__':
    main()